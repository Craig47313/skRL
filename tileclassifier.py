''' -*- coding: utf-8 -*-
learned from Rob Mulla's 'Train Your first PyTorch Model [Card Classifier]' which can be found at https://www.kaggle.com/code/robikscube/train-your-first-pytorch-model-card-classifier
--> also learned using Kie Codes 'Image Classifier in PyTorch' which can be found at https://www.youtube.com/watch?v=igQeI29FIQM
Very heavily self modified to used pretrained resnet which got 
accuracy precision recall and f1 all at around 97.5 with 100 epochs and 95~ with 60 epochs
this code is has been modified from the colab I originally made it in https://colab.research.google.com/drive/1I3KSzAExvrsQhLlgN-Klkl03bW5RO6ud?authuser=0#scrollTo=ubocnol43kSh
'''

"""skRL_TileClassifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I3KSzAExvrsQhLlgN-Klkl03bW5RO6ud
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
from torchsummary import summary
from torchvision import models
import matplotlib.pyplot as plt
import numpy as np
from torch.utils.data import random_split
from torch.utils.data import DataLoader
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

device = torch.device("cpu")
if torch.cuda.is_available():
    device = torch.device("cuda")
elif torch.backends.mps.is_built() and torch.backends.mps.is_available():
    device = torch.device("mps")
print(device)

transform = transforms.Compose([
    transforms.Resize((224, 224)),  # ResNet expects 224x224
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                         std=[0.229, 0.224, 0.225])
])
train_set = torchvision.datasets.ImageFolder(root="./dataBalenced/test", transform=transform)
test_set = torchvision.datasets.ImageFolder(root="./dataBalenced/train", transform=transform)

train_loader = DataLoader(train_set, batch_size=4, shuffle=True)
test_loader = DataLoader(test_set, batch_size=4, shuffle=True)

classes = ("bishop", "board", "king", "knight", "pawn", "player", "queen", "rook")

print(f"Shape of the images in the training dataset: {train_loader.dataset[0][0].shape}")

'''fig, axes = plt.subplots(1, 10, figsize=(12, 3))
for i in range(10):
    image = train_loader.dataset[i][0].permute(1, 2, 0)
    denormalized_image= image / 2 + 0.5
    axes[i].imshow(denormalized_image)
    axes[i].set_title(classes[train_loader.dataset[i][1]])
    axes[i].axis('off')
plt.show()
not needed really
'''

#create resnet model
import os
import certifi
os.environ['SSL_CERT_FILE'] = certifi.where() #need an ssl certificate to work and python not working to give one

net = models.resnet18(pretrained=True)
net.fc = nn.Linear(net.fc.in_features, len(classes))
net = net.to(device)



#training loop 
criterion = nn.CrossEntropyLoss()
optimizer = optim.AdamW(net.parameters(), lr=1e-4)
scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.5)

epochs = 100
for epoch in range(epochs):

    running_loss = 0.0
    for i, data in enumerate(train_loader):
        inputs, labels = data[0].to(device), data[1].to(device)

        optimizer.zero_grad()
        outputs = net(inputs)
        loss = criterion(outputs, labels)

        loss.backward()
        optimizer.step()

        running_loss += loss.item()
    print(f"[{epoch+1}/{epochs}] Loss: {running_loss/len(train_loader):.4f}")

print('Finished Training')

#save model
torch.save(net.state_dict(), "resnet_chess.pth")
print("Model saved as resnet_chess.pth")

#testing
def view_classification(image, probabilities):
    probabilities = probabilities.data.numpy().squeeze()

    fig, (ax1, ax2) = plt.subplots(figsize=(6,9), ncols=2)

    image = image.permute(1, 2, 0)
    denormalized_image= image / 2 + 0.5
    ax1.imshow(denormalized_image)
    ax1.axis('off')

    ax2.barh(np.arange(len(classes)), probabilities)
    ax2.set_aspect(0.1)
    ax2.set_yticks(np.arange(len(classes)))
    ax2.set_yticklabels(classes)
    ax2.set_title('Class Probability')
    ax2.set_xlim(0, 1.1)
    plt.tight_layout()

print("Test 10 images")
images, _ = next(iter(test_loader))
for i in range(10):
    image = images[3]
    batched_image = image.unsqueeze(0).to(device)
    with torch.no_grad():
        log_probabilities = net(batched_image)

    probabilities = torch.exp(log_probabilities).squeeze().cpu()
    view_classification(image, probabilities)
    _, predicted = torch.max(log_probabilities.data, 1)
    predictedClass = classes[predicted.item()]
    print(predictedClass)

net.eval()
all_preds = []
all_labels = []

with torch.no_grad():
    for images, labels in test_loader:
        images, labels = images.to(device), labels.to(device)

        outputs = net(images)
        _, predicted = torch.max(outputs.data, 1)

        all_preds.extend(predicted.cpu().numpy())
        all_labels.extend(labels.cpu().numpy())

acc = accuracy_score(all_labels, all_preds)
prec = precision_score(all_labels, all_preds, average="macro", zero_division=0)
rec = recall_score(all_labels, all_preds, average="macro", zero_division=0)
f1 = f1_score(all_labels, all_preds, average="macro", zero_division=0)

print(f"Test Metrics:\n"
      f"Accuracy:  {acc:.4f}\n"
      f"Precision: {prec:.4f}\n"
      f"Recall:    {rec:.4f}\n"
      f"F1 Score:  {f1:.4f}")